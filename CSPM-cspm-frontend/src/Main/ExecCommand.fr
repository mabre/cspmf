----------------------------------------------------------------------------
-- |
-- Module      :  Main.ExecCommand
-- Copyright   :  (c) Fontaine 2010-2011
-- License     :  BSD3
--
-- Maintainer  :  Fontaine@cs.uni-duesseldorf.de
-- Stability   :  experimental
-- Portability :  GHC-only
--
-- Comand line interface for the CSPM tools.
----------------------------------------------------------------------------
module Main.ExecCommand
where

import frege.Prelude hiding (empty, display, <+>)
import Language.CSPM.TranslateToProlog
import Language.CSPM.LexHelper
import Language.CSPM.Utils
import Language.CSPM.Frontend
import Language.CSPM.Rename --TODO import cleanup
import Language.CSPM.AST
import Language.CSPM.PrettyPrinter
import Text.PrettyPrint
import Data.Version

import Main.ExceptionHandler

cmdVersion :: Version
cmdVersion = makeVersion [0,1,0,0]

version :: IO ()
version = putStrLn $ "cspm command line utility version " ++ showVersion cmdVersion

numericVersion :: IO ()
numericVersion = putStrLn $ showVersion frontendVersion

verbose :: IO ()
verbose = do
    putStr $ concat
        [
        "Versions :",nl
        ,"  cspmf command line utility : ", showVersion cmdVersion, nl
        ,"  CSPM-Frontend              : ", showVersion frontendVersion, nl
        ,"  CSPM-ToProlog              : ", showVersion toPrologVersion, nl
        ,nl
        ,"Usage examples:",nl
        ,"  cspmf --help",nl
        ,"  cspmf info",nl
        ,"  cspmf translate",nl
        ,nl
        ,"Copyright (c) Marc Fontaine, Ivaylo Dobrikov 2007-2015",nl
        ,"Email : Marc.Fontaine@gmx.de, ivaylo.dobrikov@googlemail.com",nl
        ]
  where nl = "\n"

prettyOut :: FilePath -> Bool -> FilePath -> IO ()
prettyOut src rename outFile = handleException $ do
    ast <- do
          ast1 <- parseFile src
          if rename
            then fmap fst $ eitherToExc throwRenameError $ renameModule ast1
            else return $ castModule ast1
    writeFile outFile $ prettyShow ast

addUnicode :: FilePath -> FilePath -> IO ()
addUnicode src outFile = handleException $ do
    tokens <- readFile src >>= lexInclude src >>= eitherToExc throwLexError
    writeFile outFile $ concat $ map unicodeTokenString tokens

removeUnicode :: FilePath -> FilePath -> IO ()
removeUnicode src outFile = handleException $ do
    tokens <- readFile src >>= lexInclude src >>= eitherToExc throwLexError
    writeFile outFile $ concat $ map asciiTokenString tokens

prologOut :: FilePath -> FilePath -> IO ()
prologOut src outFile = do -- exception handling is done in translateToProlog
    translateToProlog src outFile

expressionToPrologTerm :: FilePath -> String -> IO ()
expressionToPrologTerm "no-file" str = handleException $ do
    translateExpToPrologTerm Nothing str
expressionToPrologTerm src str = handleException $ do
    translateExpToPrologTerm (Just src) str

declarationToPrologTerm :: FilePath -> String -> IO ()
declarationToPrologTerm "no-file" str = handleException $ do
    translateDeclToPrologTerm Nothing str
declarationToPrologTerm src str = handleException $ do
    translateDeclToPrologTerm (Just src) str

--- not to be called directly, only for testing purpose, use frege.main.Main instead
main args = do
    prologOut (args !! 0) (args !! 1)
